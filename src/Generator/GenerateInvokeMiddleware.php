<?php

declare(strict_types=1);

namespace Jasny\SwitchRoute\Generator;

use Jasny\SwitchRoute\InvalidRouteException;
use Jasny\SwitchRoute\Invoker;
use Psr\Http\Message\ServerRequestInterface;
use ReflectionException;

/**
 * Generate a script that invokes .
 */
class GenerateInvokeMiddleware extends AbstractGenerate
{
    /**
     * @var Invoker
     */
    protected $invoker;

    /**
     * GenerateScript constructor.
     *
     * @param Invoker $invoker
     */
    public function __construct(Invoker $invoker = null)
    {
        $this->invoker = $invoker ?? new Invoker();
    }

    /**
     * Invoke code generation.
     *
     * @param string $name      Class name
     * @param array  $routes    Ignored
     * @param array  $structure
     * @return string
     */
    public function __invoke(string $name, array $routes, array $structure): string
    {
        $invokeCode = self::indent($this->generateSwitchFromRoutes($routes), 8)
            . (!isset($structure['*']) ? "\n\n" . '$this->notFound($request);' : '');

        [$namespace, $class] = $this->generateNs($name);

        return <<<CODE
<?php
{$namespace}
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Psr\Http\Message\ResponseFactoryInterface;

/**
 * PSR-15 compatible middleware that invokes an action based on the route attributes of the server request.
 *
 * This file is generated by SwitchRoute.
 * Do not modify it manually. Any changes will be overwritten.
 */
class {$class} implements MiddlewareInterface
{
    /**
     * @var ResponseFactoryInterface
     */
    protected \$responseFactory;

    /**
     * @var callable
     */
    protected \$instantiate;

    /**
     * @param ResponseFactoryInterface \$responseFactory  Used for default not-found response.
     * @param callable                 \$instantiate      Instantiate controller / action classes.
     */
    public function __construct(ResponseFactoryInterface \$responseFactory, ?callable \$instantiate = null)
    {
        \$this->responseFactory = \$responseFactory;
        \$this->instantiate = \$instantiate;
    }

    /**
     * The default action for when no route matches.
     */
    protected function notFound(ServerRequestInterface \$request): ResponseInterface
    {
        \$allowedMethods = \$request->getAttribute('route:allowed_methods', []);

        if (\$allowedMethods === []) {
            \$response = \$this->responseFactory->createResponse(404)
                ->withHeader('Content-Type', 'text/plain');
            \$response->getBody()->write('Not Found');
        } else {
            \$response = \$this->responseFactory->createResponse(405)
                ->withHeader('Content-Type', 'text/plain')
                ->withHeader('Allow', join(', ', \$allowedMethods));
            \$response->getBody()->write('Method Not Allowed');
        }

        return \$response;
    }

    /**
     * Process an incoming server request.
     */
    public function process(ServerRequestInterface \$request, RequestHandlerInterface \$handler): ResponseInterface
    {
        if (\$request->getAttribute('route:include', null) !== null) {
            require \$request->getAttribute('route:include');
        }

        \$controller = \$request->getAttribute('route:controller', '');
        \$action = \$request->getAttribute('route:action', '');

{$invokeCode}
    }
}
CODE;
    }

    /**
     * Generate the PHP script with a switch for routing.
     *
     * @param array $routes
     * @return string
     */
    protected function generateSwitchFromRoutes(array $routes): string
    {
        $grouped = $this->groupRoutes($routes);
        $grouped[''][''] = null;

        $code[] = "switch (\$controller) {";

        foreach ($grouped as $controller => $routes) {
            $code[] = "    case '" . addslashes($controller) . "':";
            $code[] = "        switch (\$action) {";

            foreach ($routes as $action => $key) {
                $route = [
                    'controller' => $controller !== '' ? $controller : null,
                    'action' => $action !== '' ? $action : null,
                ];

                $code[] = self::indent("case '" . addslashes($action) . "':", 12);
                $code[] = $key !== null
                    ? self::indent($this->generateRoute($key, $route, []), 16)
                    : self::indent('return $this->notFound($request);', 16);
            }
            $code[] = "        }";
            $code[] = "        break;";
        }

        $code[] = "}";

        return join("\n", $code);
    }

    /**
     * Group routes by controller name.
     *
     * @param array[] $routes
     * @return array
     */
    protected function groupRoutes(array $routes): array
    {
        $grouped = [];

        foreach ($routes as $key => $route) {
            if (isset($route['include'])) {
                continue;
            }

            if (!isset($route['controller']) && !isset($route['action'])) {
                throw new InvalidRouteException("Route for '$key' should specify 'include', 'controller', " .
                    "or 'action'");
            }

            $controller = $route['controller'] ?? '';
            $action = $route['action'] ?? '';

            if (!isset($grouped[$controller][$action])) {
                $grouped[$controller][$action] = $key;
            }
        }

        return $grouped;
    }

    /**
     * Generate routing code for an endpoint.
     *
     * @param string $key
     * @param array  $route
     * @param array  $vars
     * @return string
     * @throws InvalidRouteException
     */
    protected function generateRoute(string $key, array $route, array $vars): string
    {
        try {
            $invocation = $this->invoker->generateInvocation(
                $route['controller'] ?? null,
                $route['action'] ?? null,
                function ($name, $type, $default) {
                    if ($type == ServerRequestInterface::class || is_a($type, ServerRequestInterface::class, true)) {
                        return '$request';
                    }

                    return "\$request->getAttribute('route:{" . addslashes($name) . "}', "
                        . var_export($default, true) . ")";
                },
                '(isset($this->instantiate) ? ($this->instantiate)(\'%1$s\') : new \\%1$s)'
            );
        } catch (ReflectionException $exception) {
            throw new InvalidRouteException("Invalid route for '$key'. ". $exception->getMessage(), 0, $exception);
        }

        return "return $invocation;";
    }
}
