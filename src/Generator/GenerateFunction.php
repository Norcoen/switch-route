<?php

declare(strict_types=1);

namespace Jasny\SwitchRoute\Generator;

use Jasny\SwitchRoute\Endpoint;
use Jasny\SwitchRoute\InvalidRouteException;
use Jasny\SwitchRoute\Invoker;
use ReflectionException;

/**
 * Generate a function that invokes an action based on the route.
 */
class GenerateFunction extends AbstractGenerate
{
    /**
     * @var Invoker
     */
    protected $invoker;

    /**
     * GenerateScript constructor.
     *
     * @param Invoker $invoker
     */
    public function __construct(Invoker $invoker = null)
    {
        $this->invoker = $invoker ?? new Invoker();
    }

    /**
     * Invoke code generation.
     *
     * @param string $name       Function name
     * @param array  $routes     Ignored
     * @param array  $structure
     * @return string
     */
    public function __invoke(string $name, array $routes, array $structure): string
    {
        $default = $structure['*'] ?? null;
        unset($structure['*']);

        $switchCode = self::indent($this->generateSwitch($structure));
        $defaultCode = self::indent($this->generateDefault($default));

        return <<<CODE
<?php

/**
 * This function is generated by SwitchRoute.
 * Do not modify it manually. Any changes will be overwritten.
 */
function {$name}(string \$method, string \$path)
{
    \$segments = \$path === "/" ? [] : explode("/", trim(\$path, "/"));
    \$allowedMethods = [];

$switchCode

$defaultCode
}
CODE;
    }

    /**
     * Generate code for an endpoint
     *
     * @param Endpoint $endpoint
     * @return string
     */
    protected function generateEndpoint(Endpoint $endpoint): string
    {
        $exportValue = function ($var) {
            return var_export($var, true);
        };

        return join("\n", [
            "\$allowedMethods = [" . join(', ', array_map($exportValue, $endpoint->getAllowedMethods())) . "];",
            parent::generateEndpoint($endpoint)
        ]);
    }

    /**
     * Generate routing code for an endpoint.
     *
     * @param string        $key
     * @param array         $route
     * @param array         $vars
     * @param callable|null $genArg
     * @return string
     * @throws InvalidRouteException
     */
    protected function generateRoute(string $key, array $route, array $vars, ?callable $genArg = null): string
    {
        if (!isset($route['include']) && !isset($route['controller']) && !isset($route['action'])) {
            throw new InvalidRouteException("Route for '$key' should specify 'include', 'controller', " .
                "or 'action'");
        }

        if (isset($route['include'])) {
            return "return require '" . addslashes($route['include']) . "';";
        }

        try {
            $invocation = $this->invoker->generateInvocation(
                $route['controller'] ?? null,
                $route['action'] ?? null,
                $genArg ?? function ($name, $type, $default) use ($vars) {
                    return isset($vars[$name]) ? "\$segments[{$vars[$name]}]" : var_export($default, true);
                }
            );
        } catch (ReflectionException $exception) {
            throw new InvalidRouteException("Invalid route for '$key'. ". $exception->getMessage(), 0, $exception);
        }

        return "return $invocation;";
    }

    /**
     * Generate code for when no route matches.
     *
     * @param Endpoint|null $endpoint
     * @return string
     * @throws InvalidRouteException
     */
    protected function generateDefault(?Endpoint $endpoint): string
    {
        if ($endpoint === null) {
            return <<<CODE
if (\$allowedMethods === []) {
    http_response_code(404);
    echo "Not Found";
} else {
    http_response_code(405);
    header('Allow: ' . join(', ', \$allowedMethods));
    echo "Method Not Allowed";
}
CODE;

        }

        $genArg = function ($name, $type, $default) {
            return "\${$name} ?? " . var_export($default, true);
        };

        return $this->generateRoute('default', $endpoint->getRoutes()[''], [], $genArg);
    }
}
